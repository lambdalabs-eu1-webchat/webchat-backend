const express = require('express');
const routes = express.Router();
require('dotenv').config();

const stripe = require('stripe')(process.env.STRIPE_SK);
const PAYMENT_PLANS = require('../utils/PAYMENT_PLANS');
const errorMessage = require('../utils/errorMessage');
const { models } = require('../models/index');

/*
What are the major pieces of validation (middleware) we need for the payment endpoints?
Check if a customer is elligibile to switch plans with user count -> DB
Check if a customer is  elligible to remove their plan with user count -> DB
Check if a customers payments have expired (affects all other operations in the app so will need to be at the top-level of the server)
*/

/*
[POST]
path: '/subscription'
@body: 
{
    token: generated by stripe,
    plan: 'Plus OR Pro plan IDs',
    email: that will be associated with billing for invoices/receipts etc,
    hotel_id: hotel _id,
}
*/
routes.post('/', async (req, res, next) => {
  const { id, card, email, plan, hotel_id } = req.body;
  try {
    const customer = await stripe.customers.create({
      email,
      description: 'Create new customer',
      source: id,
    });
    if (plan === PAYMENT_PLANS.PLUS_PLAN || plan === PAYMENT_PLANS.PRO_PLAN) {
      await addSubscription(plan, customer, card, hotel_id);
    } else {
      res.status(400).json(errorMessage.invalidPlan);
    }
    const updatedHotel = await models.Hotel.findById({ _id: hotel_id });
    res.status(201).json(updatedHotel);
  } catch (error) {
    next(error);
  }
});

// add new payment/customer to a paid plan
const addSubscription = async (plan, customer, card, hotel_id) => {
  try {
    const subscription = await stripe.subscriptions.create({
      customer: customer.id,
      items: [
        {
          plan,
        },
      ],
    });
    await sendSubToDb(customer, card, subscription, plan, hotel_id);
  } catch (error) {
    console.error(error);
  }
};

// update the human-readable plan key and create a billing object on the hotel resource
const sendSubToDb = async (customer, card, subscription, plan, hotel_id) => {
  const hotel = await models.Hotel.findById({ _id: hotel_id });
  const billingObj = {
    customer: {
      id: customer.id,
      email: customer.email,
    },
    card: {
      id: card.id,
      last_four: card.last4,
      brand: card.brand,
      expiration: {
        month: card.exp_month,
        year: card.exp_year,
      },
    },
    plan_id: plan,
    sub_id: subscription.id,
  };
  try {
    if (plan === PAYMENT_PLANS.PLUS_PLAN) {
      hotel.plan = 'plus';
    } else {
      hotel.plan = 'pro';
    }
    hotel.billing = billingObj;
    await hotel.save();
  } catch (error) {
    console.error(error);
  }
};

/*
[PUT]
path: '/subscription'
@body: 
{
    hotel_id: (tbd - could be taken from decodedToken),
    newPlan: (Plus OR Pro plan IDs),
}
*/
routes.put('/', async (req, res, next) => {
  const { hotel_id, newPlan } = req.body;
  try {
    if (
      newPlan === PAYMENT_PLANS.PLUS_PLAN ||
      newPlan === PAYMENT_PLANS.PRO_PLAN ||
      newPlan === PAYMENT_PLANS.FREE_PLAN
    ) {
      await changeSubscription(hotel_id, newPlan);
      const updatedHotel = await models.Hotel.findById({ _id: hotel_id });
      res.status(200).json(updatedHotel);
    } else {
      res.status(400).json(errorMessage.invalidPlan);
    }
  } catch (error) {
    next(error);
  }
});

// change customers plan from Plus to Pro or Pro to Plus
const changeSubscription = async (hotel_id, newPlan) => {
  try {
    const hotel = await models.Hotel.findById({ _id: hotel_id });
    const currentSubscription = hotel.billing.sub_id;
    const subscription = await stripe.subscriptions.retrieve(
      currentSubscription,
    );
    // note subscription id does not change on sub changes in Stripe
    const updatedSubscription = await stripe.subscriptions.update(
      currentSubscription,
      {
        cancel_at_period_end: false,
        items: [
          {
            id: subscription.items.data[0].id,
            plan: newPlan,
          },
        ],
      },
    );
    await updateSubOnDb(hotel, updatedSubscription, newPlan);
  } catch (error) {
    console.error(error);
  }
};

// update the human-readable plan key and ammend the plan_id on the billing object
const updateSubOnDb = async (hotel, updatedSubscription, newPlan) => {
  try {
    hotel.plan = updatedSubscription.plan.nickname;
    hotel.billing.plan_id = newPlan;
    await hotel.save();
  } catch (error) {
    console.error(error);
  }
};

// /*
// [DELETE]
// path: '/subscription'
// params: /hotel_id

// THIS REMOVES EXISTING SUBS AND MOVES CUSTOMER ONTO THE PLACEHOLDER FREE SUB
// */
// routes.delete('/:hotel_id', async (req, res, next) => {
//   const { hotel_id } = req.params;
//   try {
//     // grab current sub from hotel billing obj
//     const hotel = await models.Hotel.findById({ _id: hotel_id });
//     const currentSubscription = hotel.billing.sub_id;
//     await stripe.subscriptions.update(currentSubscription, {
//       cancel_at_period_end: true,
//     });
//     await removeSubFromDb(hotel);
//     const updatedHotel = await models.Hotel.findById({ _id: hotel_id });
//     res.status(200).json(updatedHotel);
//   } catch (error) {
//     next(error);
//   }
// });

// const removeSubFromDb = async (hotel) => {
//   hotel.plan = 'free';
//   hotel.billing.plan_id = undefined;
// };

/*
[PUT]
path: '/subscription/method'
@body: 
{  
    token: generated by stripe,
    FOR_TESTING_ONLY:
    customer_id: harcoded string from Stripe dashboard 
}
What does this endpoint need to be able to do?
Update customer payment methods -> Stripe and DB (updates the hotels billing object with a new default source)
*/
routes.put('/:method', async (req, res, next) => {
  const { id, card, customer } = req.body;
  try {
    await stripe.customers.update(customer, {
      source: id,
    });
    updatePaymentInDb(card, customer);
  } catch (error) {
    next(error);
  }
});

const updatePaymentInDb = (card, customer) => {
  console.log({ card, customer });
};

module.exports = routes;
